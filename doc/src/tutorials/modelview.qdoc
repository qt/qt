/*!

    \page modelview.html
    \startpage {index.html}{Qt Reference Documentation}
    \contentspage Tutorials
    \contentspage{modelview.html}{Crash Course in Model/View Programming}

\title Crash Course in Model/View Programming
Contents:
\tableofcontents

\section1 1 Introduction
Model/View is a technology used to separate data from views in widgets that handle data sets. Standard Widgets are not designed for separating data from views and this is why Qt 4 has two different types of widgets. Both types of widgets look the same, but they interact with data differently.
    \table
        \row
            \o  Standard widgets use data that is part of the widget.
            \o  \image standardwidget.png
        \row
            \o  View classes operate on external data (the model)
            \o  \image modelview.png
    \endtable
\section2 1.1 Standard widgets
Let's have a closer look at a standard table widget. A table widget is a 2D array of the data elements that the user can change. The table widget can be integrated into a program flow by reading and writing the data elements that the table widget provides. This method is very intuitive and useful in many applications.

Displaying and editing a database table with a standard table widget can be problematic. Two copies of the data have to be coordinated: one outside the widget; one inside the widget. The developer needs to know where up-to-date data is so the both copies contain the most recent data. The tight coupling of presentation and data makes it harder to write unit tests.

\section2 1.2 Model/View to the rescue
Model/View stepped up to provide a solution that uses a more versatile architecture. Model/View eliminates the data consistency problems that may occur with standard widgets. Model/View also makes it easier to use more than one view of the same data because one model can be passed on to many views. The most important difference is that model/view widgets do not store data behind the table cells. In fact, they operate directly from your data. Since view classes do not know your data's structure, you need to provide a wrapper to make your data conform to the \l QAbstractItemModel interface. A view uses this interface to read from and write to your data and any class that implements \l QAbstractItemModel is a model. Once the view receives a pointer to a model, it will read and display its content and be its editor.

\section2 1.3 Overview of  the model/view widgets
Here is an overview of the model/view widgets and their corresponding standard widgets.
    \table
        \header
            \o  Widget
            \o  Standard Widget
(a convenience class with data in the widget)
            \o  Model/View View Class (for use with external data)
        \row
            \o  \image listview.png
            \o  \l QListWidget
            \o  \l QListView
        \row
            \o  \image tableview.png
            \o  \l QTableWidget
            \o  \l QTableView
        \row
            \o  \image treeview.png
            \o  \l QTreeWidget
            \o  \l QTreeView
        \row
            \o  \image columnview.png
            \o   
            \o  \l QColumnView shows a tree as a hierarchy of lists
        \row
            \o  \image combobox.png
            \o {2, 1} \l QComboBox can work as both a view class and also as a traditional widget
    \endtable
\section2 1.4 Having adapters between forms and models can come in handy.
We often prefer editing data stored in tables (e.g. in database tables) in forms rather than in tables. There is no direct model/view counterpart for separating data and views for widgets that operate on one value instead of a dataset, so we need an adapter in order to connect the form to the source of  data.

\l QDataWidgetMapper is a great solution because it maps form widgets to a table row and it makes it very easy to build forms for database tables. \image widgetmapper.png

Another example of an adapter is \l QCompleter. Qt has QCompleter for providing auto completions in Qt widgets such as \l QComboBox and, as shown below, \l QLineEdit. \l QCompleter uses a model as its data source, so \l QCompleter, in itself, is a very handy adapter. \image qcompleter.png

\section1 2 A Simple Model/View Application
If you want to develop a model/view application, where should you start? We recommend starting with a simple example and extending it step-by-step. This makes understanding the architecture a lot easier. Trying to understand the model/view architecture in detail before invoking the IDE has proven to be less convenient for many developers. It is substantially easier to start with a simple model/view application that has demo data. Give it a try! Simply replace the data in the examples below with your own.

Below are 7 very simple and independent applications that show different sides of model/view programming. The source code can be downloaded from  @todo___________paste link here_________________________

\section2 2.1 A read only table
We start with an application that uses a \l QTableView to show data. We will add editing capabilities later. 

-------------------------------------------------------------main.cpp---------------------
    \snippet examples/tutorials/modelview/1_readonly/main.cpp

We have the usual main() function;
-------------------------------------------------------------modelview.h---------------------
    \snippet examples/tutorials/modelview/1_readonly/modelview.h

The application is a \l QMainWindow that holds a \l QTableView.  

-------------------------------------------------------------modelview.cpp---------------------
    \snippet examples/tutorials/modelview/1_readonly/modelview.cpp

Here is the interesting part: We use \c tableView->setModel(new MyModel(this) ); to instantiate the Model and pass its pointer to \l {QTableView::}{tableView()} OR \l QTableView::tableView() OR \l QTableView::tableView .  \l {QTableView::}{tableView} will invoke the methods of the pointer it has received to find out two things: 
    \list
       \o   How many rows and columns should be displayed
       \o   What content should be printed into each cell.
    \endlist

The model needs some code to respond to this. 

We have a table data set, so let's start with QAbstractTableModel since it is easier to use.
-------------------------------------------------------------mymodel.h---------------------
    \snippet examples/tutorials/modelview/1_readonly/mymodel.h

QAbstractTableModel requires the implementation of three abstract methods.


-------------------------------------------------------------mymodel.cpp---------------------
    \snippet examples/tutorials/modelview/1_readonly/mymodel.cpp

The number of rows and columns is set by \c MyModel::rowCount() and \c MyModel::columnCount(). 
When the view has to know what the cell 's text is, it calls the \l{QAbstractItemModel::data()}{data()} method. Row and column information is specified with parameter \c index and the role is set to Qt::Display Role.  Other roles are covered in the next section. In our example, the data that should be displayed is generated. In a real application, \c MyModel would have a member called \c MyData, which serves as the target for all reading and writing operations. 

This small example demonstrates the passive nature of a model. The model does not know when it will be used or which data is needed. It simply provides data each time the view requests it. 

What happens when the model 's data needs to be changed? How does the view know when data changes and needs to be read again? The model has to emit a signal that indicates what range of cells has changed.  This will be demonstrated in section 2.3.

\section2 2.2 Extending the read only example with roles
In addition to controlling what text the view displays, the model also controls the text's appearance. When we slightly change the model, we get the following result: \image readonlytable_role.png


In fact, nothing except for the \l{QAbstractItemModel::data()}{data()} method needs to be changed to set fonts, background colour, alignment and a checkbox. Here is the \l{QAbstractItemModel::data()}{data()} method that produces the result shown above:

-------------------------------------------------------------mymodel.cpp---------------------
    \snippet examples/tutorials/modelview/2_formatting/mymodel.cpp

Each formatting property will be requested from the model with a separate call to the \l{QAbstractItemModel::data()}{data()} method. The \c role parameter is used to let the model know which property is being requested:

    \table
        \header
            \o  Role (enum Qt::ItemDataRole )
            \o  Meaning
            \o  Type 
        \row
            \o  Qt::DisplayRole
            \o  text
            \o  QString
        \row
            \o  Qt::FontRole
            \o  font
            \o  QFont
        \row
            \o  Qt::BackgroundRole
            \o  brush for the background of the cell
            \o  QBrush
        \row
            \o  Qt::TextAlignmentRole
            \o  text alignment
            \o  enum Qt::AlignmentFlag
        \row
	    \o {1, 3} Qt::CheckStateRole
	    \o {1, 3} suppresses checkboxes with QVariant(), sets checkboxes with Qt::Checked or Qt::Unchecked
	    \o {1, 3} enum Qt::ItemDataRole

    \endtable

Refer to Qt documentation to learn more about  enum Qt::ItemDataRole's capabilities.


Now we need to determine how using a seperated model impacts the application's performance, so let's trace how often the view calls the \l{QAbstractItemModel::data()}{data()} method. In order to track how often the view calls the model, we have put a debug statement in the \l{QAbstractItemModel::data()}{data()} method, which logs onto stdio. In our small example, \l{QAbstractItemModel::data()}{data()} will be called 42 times. Each time you hover the cursor over the field, \l{QAbstractItemModel::data()}{data()} will be called again - 7 times for each cell. That's why it is  important to make sure that your data is available when \l{QAbstractItemModel::data()}{data()}) is invoked and expensive lookup operations are cached.

\section2 2.3 A clock inside a table cell
\image clock.png

We still have a read only table, but this time the content changes every second because we are showing the current time.

!!!!!I CAN'T FIND THIS FILE!!!!!
\code
QVariant MyModel::data(const QModelIndex &index, int role ) const
{
    QVariant returnVal;
    int row = index.row();
    int col = index.column();

    if(role == Qt::DisplayRole)

    {
        if(row == 0 && col == 0 )
        {
            returnVal = QTime::currentTime().toString();
       }
    }
    return returnVal;
}
\endcode

Something is missing to make the clock tick. We need to tell the view every second that the time has changed and that it needs to be read again. We do this with a timer. In the constructor, we set its interval to 1 second and it connect its timeout signal.

?????(include section from 3_changingmodel/mymodel.cpp)?????
\code
MyModel::MyModel(QObject *parent)
    :QAbstractTableModel(parent)
{
//    selectedCell = 0;
    timer = new QTimer(this);
    timer->setInterval(1000);
    connect(timer, SIGNAL(timeout()) , this, SLOT(timerHit()) );
    timer->start();
}
\endcode

Here is the corresponding slot:

?????(include section from 3_changingmodel/mymodel.cpp)?????
\code

void MyModel::timerHit()
{
    //we identify the top left cell
    QModelIndex topLeft = createIndex ( 0,0 );
    //emit a signal to make the view reread identified data
    emit dataChanged ( topLeft, topLeft );
}
\endcode

We ask the view to read the data in the top left cell again by emitting the \l{QAbstractItemModel::dataChanged()}{dataChanged()} signal.  Note that we did not explicitly connect the \l{QAbstractItemModel::dataChanged()}{dataChanged()} signal to the view. This happened automatically when we called \l{QAbstractItemModel::setModel()}{setModel()} .

\section2 2.4 Setting up Headers for Columns and Rows
Headers can be hidden via a view method. 
\c tableView->verticalHeader()->hide();
\image header.png


The header content, however , is set via the model, so we reimplement the \l{QAbstractItemModel::headerData()}{headerData()} method:


?????(include section from 4_headers/mymodel.cpp)?????
\code
QVariant MyModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (role == Qt::DisplayRole)
    {
        if (orientation == Qt::Horizontal) {
            switch (section)
            {
            case 0:
                return QString("first");
            case 1:
                return QString("second");
            case 2:
                return QString("third");
            }
        }
    }
    return QVariant();
}
\endcode


\section2 2.5 The minimal Editing example
In this example, we are going to build an application that automatically populates a window title with content by repeating values entered into table cells.

The model decides whether editing capabilities are available . We only have to modify the model in order for the available editing capabilities to be enabled. This is done by reimplementing the following virtual methods:  \l{QAbstractItemModel::setData()}{setData()} and \l{QAbstractItemModel::flags()}{flags()}. 
-------------------------------------------------------------mymodel.h---------------------
    \snippet examples/tutorials/modelview/5_edit/mymodel.h

We use \c QStringList m_gridData to store our data. This makes \c m_gridData the core of MyModel.  The rest of \c MyModel acts like a wrapper and adapts \c m_gridData to the  QAbstractItemModel interface. We have also introduced the \l{QAbstractItemModel::editCompleted()}{editCompleted()} signal, which makes it possible to transfer the modified text to the window title. 

?????(include section from 5_edit/mymodel.cpp)?????
\code
#include "mymodel.h"

const int COLS= 3;
const int ROWS= 2;

MyModel::MyModel(QObject *parent)
    :QAbstractTableModel(parent)
{
    //gridData needs to have 6 element, one for each table cell
    m_gridData << "1/1" << "1/2" << "1/3" << "2/1" << "2/2" << "2/3" ;
}
\endcode

In the constructor, we fill \c QStringList gridData with 6 items. (one item for every field in the table)
?????(include section from 5_edit/mymodel.cpp)?????
\code
HIER FEHLT WAS!!!
\endcode

\l{QAbstractItemModel::setData()}{setData()} will be called each time the user edits a cell. The \c index parameter tells us which field has been edited and \c value  provides the result of the editing process. The role will always be set to \c Qt::EditRole because our cells only contain text. If a checkbox were present and user permissions are set to allow the checkbox to be selected, calls would also be made with the role set to \c Qt::CheckStateRole. 
?????(include section from 5_edit/mymodel.cpp)?????
\code
HIER FEHLT WAS!!!
\endcode

Various properties of a cell can be adjusted with \l{QAbstractItemModel::flags()}{flags()}. Returning \c Qt::ItemIsEditable | Qt::ItemIsEnabled is enough to show an editor that a cell has been selected. If editing one cell modifies more data than the data in that particular cell, the model must emit a \l{QAbstractItemModel::dataChanged()}{dataChanged()}  signal in order for the data that has been changed to be read.

\section1 3 Intermediate Topics
\section2 3.1 TreeView
You can convert the example above into an application with a tree view. Simply replace QTableView with QTreeView, which results in a read/write tree. No changes have to be made to the model. The tree won't have any hierarchies because there aren't any hierarchies in the model itself.
\image dummy_tree.png


QListView, QTableView and QTreeView all use a model abstraction, which is a merged list, table and tree. This makes it possible to use several different types of view classes from the same model.
\image list_table_tree.png

This is how our example model looks so far:
\image example_model.png


We want to, however, present a real tree. We have wrapped our data in the examples above in order to make a model. This time we use QStandardItemModel, which is a container for hierarchical data that also implements QAbstractItemModel. To show a tree, QStandardItemModel must be populated with QStandardItems, which are able to hold all the standard properties of items like text, fonts, checkboxes or brushes. \image tree_2_with_algorithm.png
-------------------------------------------------------------modelview.cpp---------------------
    \snippet examples/tutorials/modelview/6_treeview/modelview.cpp

We simply instantiate a QStandardItemModel and add a couple of QStandardItems to the constructor. We can then make a hierarchical data structure because a QStandardItem can hold other QStandardItems. Nodes are collapsed and expanded within the view.

\section2 3.2 Working with selection
We want to access a selected item's content in order to output it into the window title together with the hierarchy level.
\image selection2.png


So let's create a couple of items:
?????(include section from 7_selections/modelview.cpp)?????
\code
#include <QTreeView>
#include <QStandardItemModel>
#include <QItemSelectionModel>
#include "modelview.h"

ModelView::ModelView(QWidget *parent)
    : QMainWindow(parent)
{
    treeView = new QTreeView(this);
    setCentralWidget(treeView);
    standardModel = new QStandardItemModel ;
    QStandardItem *rootNode = standardModel->invisibleRootItem();


    //defining a couple of items
    QStandardItem *americaItem = new QStandardItem("America");
    QStandardItem *mexicoItem =  new QStandardItem("Canada");
    QStandardItem *usaItem =     new QStandardItem("USA");
    QStandardItem *bostonItem =  new QStandardItem("Boston");
    QStandardItem *europeItem =  new QStandardItem("Europe");
    QStandardItem *italyItem =   new QStandardItem("Italy");
    QStandardItem *romeItem =    new QStandardItem("Rome");
    QStandardItem *veronaItem =  new QStandardItem("Verona");

    //building up the hierarchy
    rootNode->    appendRow(americaItem);
    rootNode->    appendRow(europeItem);
    americaItem-> appendRow(mexicoItem);
    americaItem-> appendRow(usaItem);
    usaItem->     appendRow(bostonItem);
    europeItem->  appendRow(italyItem);
    italyItem->   appendRow(romeItem);
    italyItem->   appendRow(veronaItem);
    
    //register the model
    treeView->setModel( standardModel );
    treeView->expandAll();

    //selection changes shall trigger a slot
    QItemSelectionModel *selectionModel= treeView->selectionModel();
    connect(selectionModel, SIGNAL(selectionChanged ( const QItemSelection & , const QItemSelection & )),
            this, SLOT(selectionChangedSlot(const QItemSelection & , const QItemSelection & )));
}
\endcode

Views manage selections within a separate selection model, which can be retrieved with the \l{QAbstractItemModel::selectionModel()}{selectionModel()} method. We retrieve the selection Model in order to connect a slot to its \l{QAbstractItemModel::selectionChanged()}{selectionChanged()} signal.

?????(include section from 7_selections/modelview.cpp)?????
\code
HIER FEHLT WAS!!!
\endcode

We get the model index that corresponds to the selection by calling 
\c treeView->selectionModel()->currentIndex() and we get the the field's string by using the model index. Then we just calculate the item's \c hierarchyLevel.  Top level items do not have parents and the \l{QAbstractItemModel::parent()}{parent()} method will return a default constructed QModelIndex(). This is why we use the \l{QAbstractItemModel::parent()}{parent()} method to iterate to the top level while counting the steps performed during iteration.

The selection model (as shown above) can be retrieved, but it can also be set with \c QAbstractItemView::setSelectionModel. This is how it's possible to have 3 view classes with synchronised selections because only one instance of a selection model is used. The instance of a selection model is retrieved from the first view class with \l{QAbstractItemModel::selectionModel()}{selectionModel()} and the result is assigned to the second and third view class with \l{QAbstractItemModel::setSelectionModel()}{setSelectionModel()};
\section2 3.3 Predefined Models
The typical way to use model/view is to wrap specific data to make it usable with view classes. Qt, however, also provides predefined models for common underlying data structures. If one of the available data structures is suitable for your application, a predefined model can be a good choice.

    \table
        \row
            \o  QStringListModel
            \o  Stores a list of strings
        \row
            \o  QStandardItemModel
            \o  Stores arbitrary hierarchical items
        \row
            \o  {1, 2}  QFileSystemModel
QDirModel (deprecated)
            \o  {1, 2}  Encapsulate the local file system
        \row
            \o  QSqlQueryModel
            \o  Encapsulate an SQL result set
        \row
            \o  QSqlTableModel
            \o  Encapsulates an SQL table
        \row
            \o  QSqlRelationalTableModel
            \o  Encapsulates an SQL table with foreign keys
        \row
            \o  QSortFilterProxyModel
            \o  Sorts and/or filters another model

    \endtable

\section2 3.4 Delegates
In all examples so far, data is presented as text or a checkbox in a cell and is edited as text or a checkbox. The component that provides these presentation and editing services is called a “delegate.” We are only just beginning to work with the delegate because the view uses a default delegate.  But imagine that we want to have a different editor.(e.g. a slider or a drop down list) Or imagine that we want to present data as graphics. Let's take a look at an example called Stardelegate, (  \l{http://qt.nokia.com/doc/4.6/itemviews-stardelegate.html}{http://qt.nokia.com/doc/4.6/itemviews-stardelegate.html} ) in which stars are used to show a rating: \image stardelegate.png

The view has a method that replaces the default delegate and installs a custom delegate. This method is called \l{QAbstractItemModel::setItemDelegate()}{setItemDelegate()}. A new delegate can be written by creating a class that inherits from QStyledItemDelegate. In order to write a delegate that displays stars and has no input capabilities, we only need to overwrite 2 methods.

!!!!!I CAN'T FIND THIS FILE!!!!!
\code
 class StarDelegate : public QStyledItemDelegate
 {
     Q_OBJECT
 public:
     StarDelegate(QWidget *parent = 0); 
     void paint(QPainter *painter, const QStyleOptionViewItem &option,
                const QModelIndex &index) const;
     QSize sizeHint(const QStyleOptionViewItem &option,
                    const QModelIndex &index) const;
 };

\endcode

\l{QAbstractItemModel::paint()}{paint()} draws stars depending on the content of the underlying data.  The data can be looked up with parameter \c index.data(). \c SizeHint specifies the stars dimensions so the the cell will provide  enough  height and width to accommodate the stars.

Writing custom delegates is the right choice if you want to show your data with a custom graphical  representation inside the grid of the view class. If you want to leave the grid, you can write a custom view class.

\section2 3.5 Debugging with ModelTest
The passive nature of models provides new challenges for programmers. Inconsistencies in the model can cause the application to crash. Since the model is hit by numerous calls from the view, it is hard to find out which call has crashed the application and which operation has introduced the problem. 

Qt provides software called ModelTest, which checks models while your programming is running. Every time the model is changed, ModelTest scans the model and reports errors with an assert. This is especially important for tree models, since their hierarchical nature leaves many possibilities for subtle inconsistencies. http://labs.qt.nokia.com/page/Projects/Itemview/Modeltest

Unlike view classes, ModelTest uses out of range indexes to test the model.  This means your application may crash with ModelTest even if it runs perfectly without it. So you also need to handle all of the indexes that are out of range when using ModelTest. 









\section2 3.6 Model/View NG

\image path.png

Model/View was introduced in Qt 4.0 and is a frequently used technology. Feedback from clients and new development trends have shown, that there is a need to further develop the model/view technology. Therefore a research project at Nokia is looking into ways to go beyond the current implementation.

One limitation of model/view is that view classes are basically all fixed grids. It is possible, but really hard to make a list view with icons placed on a curve; or cells expanding on mouse over events to show additional information. In order to achieve graphically rich view experiences, Model/View NG will use QGraphicsView to render elements. Nodel/View NG also aims to make model/view programming more intuitive. One way to achieve this is to have  separate models for lists, tables and trees. The current model abstraction is complex because it is capable of representing a list, a table or a tree. 

Model/View NG is a research project. You are welcome to checkout the source code, monitor progress and take part in discussions at the following address:  \l{http://labs.qt.nokia.com/page/Projects/Itemview/ItemviewsNG}{http://labs.qt.nokia.com/page/Projects/Itemview/ItemviewsNG}

\section1 4 Good Sources for Additional Information
\section2 4.1 Books
Model/View programming is covered quite extensively in the documentation of Qt but also in several good books. 
    \list 1
       \o   1.C++ GUI Programming with Qt 4 / Jasmin Blanchette, Mark Summerfield, Prentice Hall, 2nd edition, ISBN 0-13-235416-0
also available in German: C++ GUI Programmierung mit Qt 4: Die offizielle Einführung, Addison-Wesley, ISBN 3-827327-29-6
       \o   1.The Book of Qt4, The Art of Building Qt Applications / Daniel Molkentin,  Open Source Press ISBN 1-59327-147-6
Translated from: Qt 4, Einführung in die Applikationsentwicklung, Open Source Press, ISBN 3-937514-12-0
       \o   1.Foundations of Qt Development / Johan Thelin, Apress, ISBN 1-59059-831-8
    \endlist


The following list provides an overview of example programs contained in the books above. Some of them make very good templates for developing similar applications. 

    \table
        \header
            \o  example name
            \o  view class used
            \o  model used
            \o  aspects touched
            \o  
        \row
            \o  Team Leaders
            \o  QListview
            \o  QStringListModel
            \o  
            \o  Book 1, Chapter 10, Figure 10.6
        \row
            \o  Directory Viewer
            \o  QTreeView
            \o  QDirModel
            \o  
            \o  Book 1, Chapter 10, Figure 10.7
        \row
            \o  Color Names
            \o  QListView
            \o  QSortFilterProxyModel
applied to QStringListModel
            \o  
            \o  Book 1, Chapter 10, Figure 10.8
        \row
            \o  Currencies
            \o  QTableView
            \o  custom model based on
QAbstractTableModel
            \o  read only
            \o  Book 1, Chapter 10, Figure 10.10
        \row
            \o  Cities
            \o  QTableView
            \o  custom model based on
QAbstractTableModel
            \o  read / write
            \o  Book 1, Chapter 10, Figure 10.12
        \row
            \o  Boolean Parser
            \o  QTreeView
            \o  custom model based on
QAbstractItemModel
            \o  read only
            \o  Book 1, Chapter 10, Figure 10.14
        \row
            \o  Track Editor
            \o  {2, 1} QTableWidget
            \o  custom delegate providing a custom editor
            \o  Book 1, Chapter 10, Figure 10.15

        \row
            \o  Four directory views
            \o  QListView
QTableView
QTreeView
            \o  QDirModel
            \o  demonstrates the use of multiple views
            \o  Book2, Chapter 8.2
        \row
            \o  Address Book
            \o  QListView
QTableView
QTreeView
            \o  custom model based on
QAbstractTableModel
            \o  read / write
            \o  Book2, Chapter 8.4
        \row
            \o  Address Book with sorting
            \o  
            \o  QProxyModel
            \o  introducing sort and filter capabilities
            \o  Book2, Chapter 8.5
        \row
            \o  Address Book 
with checkboxes
            \o  
            \o  
            \o  introducing checkboxes
in model/view
            \o  Book2, Chapter 8.6
        \row
            \o  Address Book 
with transposed grid
            \o  
            \o  custom proxy Model based on QAbstractProxyModel
            \o  introducing a custom model
            \o  Book2, Chapter 8.7
        \row
            \o  Address Book
with drag and drop
            \o  
            \o  
            \o  introducing drag and drop support
            \o  Book2, Chapter 8.8
        \row
            \o  Address Book with custom editor
            \o  
            \o  
            \o  introducing custom delegates
            \o  Book2, Chapter 8.9
        \row
            \o  Views
            \o  QListView
QTableView
QTreeView
            \o  QStandardItemModel
            \o  read only
            \o  Book 3, Chapter 5, figure 5-3
        \row
            \o  Bardelegate
            \o  QTableView
            \o  
            \o  custom delegate for presentation based on QAbstractItemDelegate
            \o  Book 3, Chapter 5, figure 5-5
        \row
            \o  Editdelegate
            \o  QTableView
            \o  
            \o  custom delegate for editing based on QAbstractItemDelegate
            \o  Book 3, Chapter 5, figure 5-6
        \row
            \o  Singleitemview
            \o  custom view based on 
QAbstractItemView
            \o  
            \o  custom view
            \o  Book 3,
Chapter 5,
figure 5-7
        \row
            \o  listmodel
            \o  QTableView
            \o  custom Model based on
QAbstractTableModel
            \o  read only
            \o  Book 3,
Chapter 5,
Figure 5-8
        \row
            \o  treemodel
            \o  QTreeView
            \o  custom Model based on
QAbstractItemModel
            \o  read only
            \o  Book 3,
Chapter 5,
Figure 5-10
        \row
            \o  edit integers
            \o  QListView
            \o  custom Model based on 
QAbstractListModel
            \o  read / write
            \o  Book 3,
Chapter 5,
Listing 5-37, Figure 5-11
        \row
            \o  sorting
            \o  QTableView
            \o  QSortFilterProxyModel
applied to QStringListModel
            \o  demonstrates sorting
            \o  Book 3, Chapter 5, Figure 5-12

    \endtable


\section2 4.2 Qt documentation
Qt 4.6 comes with 17 examples and 2 Demonstrations for model/view.  The examples can be found here:  \l{http://doc.qt.nokia.com/4.6/examples-itemviews.html}{http://doc.qt.nokia.com/4.6/examples-itemviews.html}
    \table
        \header
            \o  example name
            \o  view class used
            \o  model used
            \o  aspects touched
        \row
            \o  Address Book
            \o  QTableView
            \o  QTableModel
QSortFilterProxyModel
            \o  usage of  QSortFilterProxyModel to generate different subsets from one data pool
        \row
            \o  Basic Sort/Filter Model
            \o  QTreeView
            \o  QStandardItemModel
QSortFilterProxyModel
            \o  
        \row
            \o  Chart
            \o  custom view
            \o  QStandardItemModel
            \o  designing custom views that cooperate with selection models 
        \row
            \o  Color Editor Factory
            \o  {2, 1}  QTableWidget
            \o  enhancing the standard delegate with a new custom editor to choose colours
        \row
            \o  Combo Widget Mapper
            \o  QDataWidgetMapper to map QLineEdit, QTextEdit and QComboBox
            \o  QStandardItemModel
            \o  shows how a QComboBox can serve as a view class
        \row
            \o  Custom Sort/Filter Model
            \o  QTreeView
            \o  QStandardItemModel
QSortFilterProxyModel
            \o  subclass QSortFilterProxyModel
for advanced sorting and filtering
        \row
            \o  Dir View
            \o  QTreeView
            \o  QDirModel
            \o  very small example to demonstrate how to assign a model to a view
        \row
            \o  Editable Tree Model
            \o  QTreeView
            \o  custom tree model
            \o  comprehensive example for working with trees, demonstrates editing cells and tree structure with an underlying custom model  
        \row
            \o  Fetch More
            \o  QListView
            \o  custom list model
            \o  dynamically changing model 
        \row
            \o  Frozen Column
            \o  QTableView
            \o  QStandardItemModel
            \o  
        \row
            \o  Pixelator
            \o  QTableView
            \o  custom table model
            \o  implementation of a custom delegate
        \row
            \o  Puzzle
            \o  QListView
            \o  custom list model
            \o  model/view with drag and drop 
        \row
            \o  Simple DOM Model
            \o  QTreeView
            \o  custom tree model
            \o  read only example for a custom tree model
        \row
            \o  Simple Tree Model
            \o  QTreeView
            \o  custom tree model
            \o  read only example for a custom tree model
        \row
            \o  Simple Widget Mapper
            \o  QDataWidgetMapper to map QLineEdit, QTextEdit and QSpinBox
            \o  QStandardItemModel
            \o  basic QDataWidgetMapper usage
        \row
            \o  Spin Box Delegate
            \o  QTableView
            \o  QStandardItemModel
            \o  custom delegate that uses a spin box as a cell editor
        \row
            \o  Star Delegate
            \o  {2, 1}  QTableWidget
            \o  comprehensive custom delegate example. 
    \endtable

Demonstrations are similar to examples except that no walk-through is provided  for the code lines. Demonstrations are also sometimes more feature rich. 
 \l{http://doc.qt.nokia.com/4.6/demos.html}{http://doc.qt.nokia.com/4.6/demos.html}
    \list
       \o   The \bold Interview demonstration shows the same model and selection being shared between three different views. 
       \o   Demonstration \bold Spreadsheet demonstrates the use of a table view as a spreadsheet, using custom delegates to render each item according to the type of data it contains.
    \endlist

A reference documentation for model/view technology is also available. \l{http://doc.qt.nokia.com/4.6/model-view-programming.html}{http://doc.qt.nokia.com/4.6/model-view-programming.html}

*/